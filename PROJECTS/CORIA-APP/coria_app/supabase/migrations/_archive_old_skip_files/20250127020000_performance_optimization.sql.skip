-- =====================================================
-- SUPABASE PERFORMANCE OPTIMIZATION - SAFE VERSION
-- Version: 1.1 - Safe Migration
-- Date: 2025-01-27
-- Purpose: Safely optimize database performance with conditional indexes
-- =====================================================

-- 1. SAFE INDEX CREATION WITH EXISTENCE CHECKS
-- =====================================================

-- Products table optimization (conditional on column existence)
DO $$
BEGIN
    -- Barcode index if barcode column exists
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'products' AND column_name = 'barcode') THEN
        CREATE INDEX IF NOT EXISTS idx_products_barcode_hash ON public.products USING HASH(barcode);
    END IF;

    -- Vegan and brand index if columns exist
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'products' AND column_name = 'vegan_status')
       AND EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'products' AND column_name = 'brand') THEN
        CREATE INDEX IF NOT EXISTS idx_products_vegan_brand ON public.products(vegan_status, brand) WHERE vegan_status != 'unknown';
    END IF;

    -- Scan count index if column exists
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'products' AND column_name = 'scan_count') THEN
        CREATE INDEX IF NOT EXISTS idx_products_scan_count_desc ON public.products(scan_count DESC) WHERE scan_count > 0;
    END IF;

    -- Updated at index if column exists
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'products' AND column_name = 'updated_at') THEN
        CREATE INDEX IF NOT EXISTS idx_products_updated_recent ON public.products(updated_at DESC);
    END IF;

    -- Metadata GIN index if column exists
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'products' AND column_name = 'metadata') THEN
        CREATE INDEX IF NOT EXISTS idx_products_metadata_gin ON public.products USING GIN(metadata);
    END IF;
END $$;

-- Brands table optimization
CREATE INDEX IF NOT EXISTS idx_brands_ethics_score_desc ON public.brands(ethics_score DESC) WHERE ethics_score IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_brands_parent_company ON public.brands(parent_company) WHERE parent_company IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_brands_certifications_gin ON public.brands USING GIN(certifications);
CREATE INDEX IF NOT EXISTS idx_brands_animal_testing ON public.brands(animal_testing_status);

-- User activities optimization
CREATE INDEX IF NOT EXISTS idx_user_activities_user_type_time ON public.user_activities(user_id, type, timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_user_activities_session ON public.user_activities(session_id);
CREATE INDEX IF NOT EXISTS idx_user_activities_target ON public.user_activities(target_id) WHERE target_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_user_activities_metadata_gin ON public.user_activities USING GIN(metadata);

-- User feedback optimization
CREATE INDEX IF NOT EXISTS idx_user_feedback_target_status ON public.user_feedback(target_id, status);
CREATE INDEX IF NOT EXISTS idx_user_feedback_rating ON public.user_feedback(rating DESC) WHERE rating IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_user_feedback_helpful ON public.user_feedback(helpful_count DESC) WHERE helpful_count > 0;
CREATE INDEX IF NOT EXISTS idx_user_feedback_tags_gin ON public.user_feedback USING GIN(tags);

-- Scan history optimization
CREATE INDEX IF NOT EXISTS idx_scan_history_user_date ON public.scan_history(user_id, scanned_at DESC);
CREATE INDEX IF NOT EXISTS idx_scan_history_barcode_date ON public.scan_history(barcode, scanned_at DESC);
CREATE INDEX IF NOT EXISTS idx_scan_history_vegan_status ON public.scan_history(is_vegan) WHERE is_vegan IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_scan_history_location_gin ON public.scan_history USING GIN(location) WHERE location IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_scan_history_nutrition_gin ON public.scan_history USING GIN(nutrition_data);

-- User achievements optimization
CREATE INDEX IF NOT EXISTS idx_user_achievements_user_unlocked ON public.user_achievements(user_id, unlocked_at DESC) WHERE unlocked_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_user_achievements_achievement ON public.user_achievements(achievement_id);
CREATE INDEX IF NOT EXISTS idx_user_achievements_progress ON public.user_achievements(user_id, progress, max_progress);

-- Controversies optimization
CREATE INDEX IF NOT EXISTS idx_controversies_brand_severity ON public.controversies(brand_id, severity);
CREATE INDEX IF NOT EXISTS idx_controversies_date_desc ON public.controversies(date DESC);
CREATE INDEX IF NOT EXISTS idx_controversies_resolved ON public.controversies(is_resolved);

-- AI usage logs optimization
CREATE INDEX IF NOT EXISTS idx_ai_usage_logs_user_date ON public.ai_usage_logs(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_ai_usage_logs_model ON public.ai_usage_logs(model);
CREATE INDEX IF NOT EXISTS idx_ai_usage_logs_tokens ON public.ai_usage_logs(tokens_used DESC) WHERE tokens_used > 0;

-- Rate limits optimization
CREATE INDEX IF NOT EXISTS idx_rate_limits_last_reset ON public.rate_limits(last_reset DESC);

-- 2. RECIPE SYSTEM OPTIMIZATION
-- =====================================================

-- Recipes optimization
CREATE INDEX IF NOT EXISTS idx_recipes_rating_count ON public.recipes(rating_avg DESC, rating_count DESC);
CREATE INDEX IF NOT EXISTS idx_recipes_dietary_filters ON public.recipes(is_vegan, is_halal, is_gluten_free);
CREATE INDEX IF NOT EXISTS idx_recipes_time_difficulty ON public.recipes(total_time_minutes, difficulty);
CREATE INDEX IF NOT EXISTS idx_recipes_cuisine_meal ON public.recipes(cuisine, meal_type);
CREATE INDEX IF NOT EXISTS idx_recipes_tags_gin ON public.recipes USING GIN(tags);
CREATE INDEX IF NOT EXISTS idx_recipes_instructions_gin ON public.recipes USING GIN(instructions);
CREATE INDEX IF NOT EXISTS idx_recipes_premium ON public.recipes(is_premium) WHERE is_premium = true;
CREATE INDEX IF NOT EXISTS idx_recipes_active_created ON public.recipes(is_active, created_at DESC) WHERE is_active = true;

-- Recipe ingredients optimization
CREATE INDEX IF NOT EXISTS idx_recipe_ingredients_recipe_order ON public.recipe_ingredients(recipe_id, display_order);
CREATE INDEX IF NOT EXISTS idx_recipe_ingredients_name ON public.recipe_ingredients(ingredient_name);
CREATE INDEX IF NOT EXISTS idx_recipe_ingredients_category ON public.recipe_ingredients(category);
CREATE INDEX IF NOT EXISTS idx_recipe_ingredients_barcode ON public.recipe_ingredients(barcode) WHERE barcode IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_recipe_ingredients_allergens_gin ON public.recipe_ingredients USING GIN(contains_allergens);

-- User recipes optimization
CREATE INDEX IF NOT EXISTS idx_user_recipes_favorite ON public.user_recipes(user_id, is_favorite) WHERE is_favorite = true;
CREATE INDEX IF NOT EXISTS idx_user_recipes_cooked ON public.user_recipes(user_id, last_cooked_at DESC) WHERE is_cooked = true;
CREATE INDEX IF NOT EXISTS idx_user_recipes_rating_user ON public.user_recipes(rating DESC, user_id) WHERE rating IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_user_recipes_planned ON public.user_recipes(planned_for) WHERE planned_for IS NOT NULL;

-- Meal plans optimization
CREATE INDEX IF NOT EXISTS idx_meal_plans_user_week_active ON public.meal_plans(user_id, week_start) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_meal_plans_week_range ON public.meal_plans(week_start, week_end);

-- Recipe collections optimization
CREATE INDEX IF NOT EXISTS idx_recipe_collections_type_public ON public.recipe_collections(collection_type, is_public);
CREATE INDEX IF NOT EXISTS idx_recipe_collections_featured ON public.recipe_collections(is_featured) WHERE is_featured = true;
CREATE INDEX IF NOT EXISTS idx_recipe_collection_items_order ON public.recipe_collection_items(collection_id, display_order);

-- 3. PANTRY SYSTEM OPTIMIZATION
-- =====================================================

-- Purchase history optimization
CREATE INDEX IF NOT EXISTS idx_purchase_history_user_status ON public.purchase_history(user_id, status);
CREATE INDEX IF NOT EXISTS idx_purchase_history_expiry ON public.purchase_history(expiry_date) WHERE expiry_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_purchase_history_purchase_date ON public.purchase_history(user_id, purchase_date DESC);

-- Pantry items optimization
CREATE INDEX IF NOT EXISTS idx_pantry_items_user_location ON public.pantry_items(user_id, location);
CREATE INDEX IF NOT EXISTS idx_pantry_items_expiry_soon ON public.pantry_items(days_until_expiry) WHERE days_until_expiry BETWEEN 0 AND 7;
CREATE INDEX IF NOT EXISTS idx_pantry_items_barcode_user ON public.pantry_items(barcode, user_id);
CREATE INDEX IF NOT EXISTS idx_pantry_items_quantity ON public.pantry_items(user_id, quantity_current) WHERE quantity_current > 0;

-- Consumption patterns optimization
CREATE INDEX IF NOT EXISTS idx_consumption_patterns_user_category ON public.consumption_patterns(user_id, product_category);
CREATE INDEX IF NOT EXISTS idx_consumption_patterns_frequency ON public.consumption_patterns(purchase_frequency_days);

-- Waste tracking optimization
CREATE INDEX IF NOT EXISTS idx_waste_tracking_user_date ON public.waste_tracking(user_id, wasted_at DESC);
CREATE INDEX IF NOT EXISTS idx_waste_tracking_reason ON public.waste_tracking(waste_reason);

-- 4. LOCALIZATION OPTIMIZATION
-- =====================================================

-- Regional products optimization
CREATE INDEX IF NOT EXISTS idx_regional_products_country_search ON public.regional_products(country_code, local_name);
CREATE INDEX IF NOT EXISTS idx_regional_products_market ON public.regional_products(country_code, market_chain);
CREATE INDEX IF NOT EXISTS idx_regional_products_price ON public.regional_products(country_code, price) WHERE price IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_regional_products_updated ON public.regional_products(updated_at DESC);

-- Cultural events optimization
CREATE INDEX IF NOT EXISTS idx_cultural_events_country_date_range ON public.cultural_events(country_code, date, end_date);
CREATE INDEX IF NOT EXISTS idx_cultural_events_type_date ON public.cultural_events(type, date);
CREATE INDEX IF NOT EXISTS idx_cultural_events_holiday ON public.cultural_events(is_public_holiday) WHERE is_public_holiday = true;

-- Translation cache optimization
CREATE INDEX IF NOT EXISTS idx_translation_cache_languages_key ON public.translation_cache(source_language, target_language, cache_key);
CREATE INDEX IF NOT EXISTS idx_translation_cache_usage ON public.translation_cache(usage_count DESC, last_used_at DESC);

-- User regional preferences optimization
CREATE INDEX IF NOT EXISTS idx_user_regional_preferences_country ON public.user_regional_preferences(country_code);
CREATE INDEX IF NOT EXISTS idx_user_regional_preferences_updated ON public.user_regional_preferences(last_location_update DESC) WHERE last_location_update IS NOT NULL;

-- 5. OPTIMIZE RLS POLICIES
-- =====================================================

-- More efficient user profile policies
DROP POLICY IF EXISTS "Users can view own profile" ON public.user_profiles;
CREATE POLICY "Users can view own profile" ON public.user_profiles
    FOR SELECT USING (auth.uid() = id);

-- Optimize scan history policies for better performance
DROP POLICY IF EXISTS "Users can view own scan history" ON public.scan_history;
CREATE POLICY "Users can view own scan history" ON public.scan_history
    FOR SELECT USING (auth.uid() = user_id OR user_id IS NULL);

-- More efficient feedback policies
DROP POLICY IF EXISTS "Feedback is viewable by everyone" ON public.user_feedback;
CREATE POLICY "Public feedback viewable" ON public.user_feedback
    FOR SELECT USING (
        status = 'approved' OR
        (auth.uid() = user_id AND auth.uid() IS NOT NULL)
    );

-- Optimize user activities policy
DROP POLICY IF EXISTS "Users can view their own activities" ON public.user_activities;
CREATE POLICY "Users can view own activities" ON public.user_activities
    FOR SELECT USING (auth.uid() = user_id);

-- 6. QUERY OPTIMIZATION FUNCTIONS
-- =====================================================

-- Function to get user's recent scans efficiently
CREATE OR REPLACE FUNCTION get_user_recent_scans(
    p_user_id UUID,
    p_limit INTEGER DEFAULT 10
) RETURNS TABLE (
    id UUID,
    barcode TEXT,
    product_name TEXT,
    is_vegan BOOLEAN,
    scanned_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        sh.id,
        sh.barcode,
        sh.product_name,
        sh.is_vegan,
        sh.scanned_at
    FROM public.scan_history sh
    WHERE sh.user_id = p_user_id
    ORDER BY sh.scanned_at DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get popular products efficiently
CREATE OR REPLACE FUNCTION get_popular_products(
    p_vegan_only BOOLEAN DEFAULT false,
    p_limit INTEGER DEFAULT 20
) RETURNS TABLE (
    id UUID,
    barcode TEXT,
    name TEXT,
    brand TEXT,
    vegan_status vegan_status,
    scan_count INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        p.id,
        p.barcode,
        p.name,
        p.brand,
        p.vegan_status,
        p.scan_count
    FROM public.products p
    WHERE (NOT p_vegan_only OR p.vegan_status = 'vegan')
    AND p.scan_count > 0
    ORDER BY p.scan_count DESC, p.updated_at DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to search products efficiently
CREATE OR REPLACE FUNCTION search_products(
    p_search_term TEXT,
    p_country_code TEXT DEFAULT NULL,
    p_limit INTEGER DEFAULT 20
) RETURNS TABLE (
    id UUID,
    barcode TEXT,
    name TEXT,
    brand TEXT,
    vegan_status vegan_status,
    scan_count INTEGER,
    source TEXT
) AS $$
BEGIN
    -- Search in main products table
    RETURN QUERY
    SELECT
        p.id,
        p.barcode,
        p.name,
        p.brand,
        p.vegan_status,
        p.scan_count,
        'global'::TEXT as source
    FROM public.products p
    WHERE (
        p.name ILIKE '%' || p_search_term || '%' OR
        p.brand ILIKE '%' || p_search_term || '%' OR
        p.barcode = p_search_term
    )
    ORDER BY p.scan_count DESC, p.updated_at DESC
    LIMIT p_limit;

    -- If country specified, also search regional products
    IF p_country_code IS NOT NULL THEN
        RETURN QUERY
        SELECT
            rp.id,
            rp.barcode,
            rp.local_name as name,
            rp.local_brand as brand,
            CASE WHEN rp.is_vegan THEN 'vegan'::vegan_status ELSE 'unknown'::vegan_status END,
            rp.search_count,
            'regional'::TEXT as source
        FROM public.regional_products rp
        WHERE rp.country_code = p_country_code
        AND (
            rp.local_name ILIKE '%' || p_search_term || '%' OR
            rp.local_brand ILIKE '%' || p_search_term || '%' OR
            rp.barcode = p_search_term
        )
        ORDER BY rp.search_count DESC, rp.updated_at DESC
        LIMIT p_limit;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 7. MATERIALIZED VIEWS FOR HEAVY QUERIES
-- =====================================================

-- Popular recipes view
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_popular_recipes AS
SELECT
    r.id,
    r.name,
    r.name_tr,
    r.rating_avg,
    r.rating_count,
    r.cook_count,
    r.view_count,
    r.total_time_minutes,
    r.difficulty,
    r.meal_type,
    r.is_vegan,
    r.is_halal,
    r.created_at
FROM public.recipes r
WHERE r.is_active = true
AND r.rating_count >= 3
ORDER BY
    (r.rating_avg * LOG(r.rating_count + 1) + r.cook_count * 0.1) DESC,
    r.created_at DESC;

CREATE UNIQUE INDEX IF NOT EXISTS idx_mv_popular_recipes_id ON mv_popular_recipes(id);
CREATE INDEX IF NOT EXISTS idx_mv_popular_recipes_dietary ON mv_popular_recipes(is_vegan, is_halal);

-- User statistics view
CREATE MATERIALIZED VIEW IF NOT EXISTS mv_user_stats AS
SELECT
    up.id as user_id,
    up.is_premium,
    COUNT(DISTINCT sh.id) as total_scans,
    COUNT(DISTINCT CASE WHEN sh.is_vegan = true THEN sh.id END) as vegan_scans,
    COUNT(DISTINCT ur.recipe_id) as saved_recipes,
    COUNT(DISTINCT CASE WHEN ur.is_favorite THEN ur.recipe_id END) as favorite_recipes,
    COUNT(DISTINCT pi.id) as pantry_items,
    MAX(sh.scanned_at) as last_scan_date,
    up.created_at as user_since
FROM public.user_profiles up
LEFT JOIN public.scan_history sh ON sh.user_id = up.id
LEFT JOIN public.user_recipes ur ON ur.user_id = up.id
LEFT JOIN public.pantry_items pi ON pi.user_id = up.id
GROUP BY up.id, up.is_premium, up.created_at;

CREATE UNIQUE INDEX IF NOT EXISTS idx_mv_user_stats_user_id ON mv_user_stats(user_id);
CREATE INDEX IF NOT EXISTS idx_mv_user_stats_premium ON mv_user_stats(is_premium);

-- Refresh materialized views daily
CREATE OR REPLACE FUNCTION refresh_materialized_views()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_popular_recipes;
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_user_stats;
END;
$$ LANGUAGE plpgsql;

-- 8. VACUUM AND ANALYZE OPTIMIZATION
-- =====================================================

-- Optimize autovacuum settings for high-traffic tables
ALTER TABLE public.scan_history SET (
    autovacuum_vacuum_scale_factor = 0.1,
    autovacuum_analyze_scale_factor = 0.05
);

ALTER TABLE public.user_activities SET (
    autovacuum_vacuum_scale_factor = 0.1,
    autovacuum_analyze_scale_factor = 0.05
);

ALTER TABLE public.products SET (
    autovacuum_vacuum_scale_factor = 0.2,
    autovacuum_analyze_scale_factor = 0.1
);

-- 9. PERFORMANCE MONITORING
-- =====================================================

-- Create performance monitoring view
CREATE OR REPLACE VIEW v_slow_queries AS
SELECT
    query,
    calls,
    total_time,
    mean_time,
    max_time,
    stddev_time
FROM pg_stat_statements
WHERE calls > 100
AND mean_time > 100
ORDER BY total_time DESC
LIMIT 20;

-- Grant permissions
GRANT SELECT ON v_slow_queries TO authenticated;
GRANT EXECUTE ON FUNCTION get_user_recent_scans TO authenticated;
GRANT EXECUTE ON FUNCTION get_popular_products TO authenticated;
GRANT EXECUTE ON FUNCTION search_products TO authenticated;

-- Success notification
DO $$
BEGIN
    RAISE NOTICE 'âš¡ Database performance optimization completed!';
    RAISE NOTICE 'ğŸ“ˆ Added 50+ critical indexes for faster queries';
    RAISE NOTICE 'ğŸ”’ Optimized RLS policies for better performance';
    RAISE NOTICE 'ğŸ” Created efficient search and lookup functions';
    RAISE NOTICE 'ğŸ“Š Added materialized views for heavy queries';
    RAISE NOTICE 'ğŸ”§ Configured autovacuum for high-traffic tables';
    RAISE NOTICE 'ğŸ“ˆ Added performance monitoring views';
END $$;