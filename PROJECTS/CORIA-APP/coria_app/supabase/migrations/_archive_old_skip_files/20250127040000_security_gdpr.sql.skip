-- =====================================================
-- SECURITY & GDPR COMPLIANCE
-- Version: 1.0
-- Date: 2025-01-27
-- Purpose: Implement security measures and GDPR compliance features
-- =====================================================

-- 1. AUDIT LOG SYSTEM
-- =====================================================

CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Who did what
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    action_type TEXT NOT NULL, -- CREATE, READ, UPDATE, DELETE, LOGIN, LOGOUT
    table_name TEXT,
    record_id TEXT,

    -- What changed
    old_values JSONB,
    new_values JSONB,
    changed_fields TEXT[],

    -- Context
    ip_address INET,
    user_agent TEXT,
    session_id TEXT,
    request_id TEXT,

    -- Metadata
    success BOOLEAN DEFAULT true,
    error_message TEXT,
    additional_info JSONB DEFAULT '{}'::jsonb,

    -- Timestamp
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for audit logs
CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON public.audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_action_type ON public.audit_logs(action_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_table_name ON public.audit_logs(table_name);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_logs_ip_address ON public.audit_logs(ip_address);

-- RLS for audit logs (only admins and the user themselves can see their logs)
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own audit logs" ON public.audit_logs
    FOR SELECT USING (auth.uid() = user_id);

-- Admin policy will be added later when user_profiles table is properly configured

-- 2. DATA ENCRYPTION
-- =====================================================

-- Enable pgcrypto for encryption functions
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Create encrypted fields table for sensitive data
CREATE TABLE IF NOT EXISTS public.encrypted_user_data (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES public.user_profiles(id) ON DELETE CASCADE,

    -- Encrypted fields (using PGP encryption)
    encrypted_phone TEXT, -- PGP encrypted phone number
    encrypted_address TEXT, -- PGP encrypted address
    encrypted_payment_info TEXT, -- PGP encrypted payment details
    encrypted_notes TEXT, -- PGP encrypted personal notes

    -- Metadata
    encryption_version INTEGER DEFAULT 1,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    CONSTRAINT unique_encrypted_user_data UNIQUE(user_id)
);

-- RLS for encrypted data
ALTER TABLE public.encrypted_user_data ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own encrypted data" ON public.encrypted_user_data
    FOR ALL USING (auth.uid() = user_id);

-- Functions for encryption/decryption
CREATE OR REPLACE FUNCTION encrypt_user_data(
    p_user_id UUID,
    p_data_type TEXT,
    p_data TEXT,
    p_passphrase TEXT
) RETURNS void AS $$
DECLARE
    v_encrypted_data TEXT;
BEGIN
    -- Encrypt data using PGP
    v_encrypted_data := pgp_sym_encrypt(p_data, p_passphrase);

    -- Store encrypted data
    INSERT INTO public.encrypted_user_data (user_id, encrypted_phone)
    VALUES (p_user_id, CASE WHEN p_data_type = 'phone' THEN v_encrypted_data END)
    ON CONFLICT (user_id) DO UPDATE SET
        encrypted_phone = CASE WHEN p_data_type = 'phone' THEN v_encrypted_data ELSE encrypted_phone END,
        encrypted_address = CASE WHEN p_data_type = 'address' THEN v_encrypted_data ELSE encrypted_address END,
        encrypted_payment_info = CASE WHEN p_data_type = 'payment' THEN v_encrypted_data ELSE encrypted_payment_info END,
        encrypted_notes = CASE WHEN p_data_type = 'notes' THEN v_encrypted_data ELSE encrypted_notes END,
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION decrypt_user_data(
    p_user_id UUID,
    p_data_type TEXT,
    p_passphrase TEXT
) RETURNS TEXT AS $$
DECLARE
    v_encrypted_data TEXT;
    v_decrypted_data TEXT;
BEGIN
    -- Only allow users to decrypt their own data
    IF auth.uid() != p_user_id THEN
        RAISE EXCEPTION 'Unauthorized access to encrypted data';
    END IF;

    -- Get encrypted data
    EXECUTE format('SELECT encrypted_%s FROM public.encrypted_user_data WHERE user_id = $1', p_data_type)
    INTO v_encrypted_data
    USING p_user_id;

    IF v_encrypted_data IS NULL THEN
        RETURN NULL;
    END IF;

    -- Decrypt data
    v_decrypted_data := pgp_sym_decrypt(v_encrypted_data, p_passphrase);

    RETURN v_decrypted_data;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 3. GDPR DATA EXPORT
-- =====================================================

-- Enhanced GDPR export function
CREATE OR REPLACE FUNCTION export_user_gdpr_data(p_user_id UUID)
RETURNS JSON AS $$
DECLARE
    user_data JSON;
    v_user_exists BOOLEAN;
BEGIN
    -- Only allow users to export their own data
    IF auth.uid() != p_user_id THEN
        RAISE EXCEPTION 'Unauthorized: Can only export own data';
    END IF;

    -- Check if user exists
    SELECT EXISTS(SELECT 1 FROM public.user_profiles WHERE id = p_user_id) INTO v_user_exists;
    IF NOT v_user_exists THEN
        RAISE EXCEPTION 'User not found';
    END IF;

    -- Log the export request
    INSERT INTO public.audit_logs (user_id, action_type, table_name, additional_info)
    VALUES (p_user_id, 'GDPR_EXPORT', 'user_data', '{"type": "full_export"}'::jsonb);

    -- Build comprehensive user data export
    SELECT json_build_object(
        'export_info', json_build_object(
            'exported_at', NOW(),
            'user_id', p_user_id,
            'export_type', 'GDPR_FULL'
        ),
        'profile', (
            SELECT row_to_json(u.*)
            FROM public.user_profiles u
            WHERE u.id = p_user_id
        ),
        'preferences', (
            SELECT row_to_json(p.*)
            FROM public.user_preferences p
            WHERE p.user_id = p_user_id
        ),
        'subscription', (
            SELECT json_build_object(
                'current_subscription', (
                    SELECT row_to_json(sub.*)
                    FROM public.user_subscriptions sub
                    WHERE sub.user_id = p_user_id
                    AND sub.status IN ('trial', 'active')
                    ORDER BY sub.created_at DESC
                    LIMIT 1
                ),
                'subscription_history', (
                    SELECT json_agg(row_to_json(sub.*))
                    FROM public.user_subscriptions sub
                    WHERE sub.user_id = p_user_id
                ),
                'payment_history', (
                    SELECT json_agg(row_to_json(pay.*))
                    FROM public.payment_history pay
                    WHERE pay.user_id = p_user_id
                )
            )
        ),
        'scan_history', (
            SELECT json_agg(
                json_build_object(
                    'id', sh.id,
                    'barcode', sh.barcode,
                    'product_name', sh.product_name,
                    'brand', sh.brand,
                    'is_vegan', sh.is_vegan,
                    'scanned_at', sh.scanned_at,
                    'location', sh.location
                )
            )
            FROM public.scan_history sh
            WHERE sh.user_id = p_user_id
        ),
        'activities', (
            SELECT json_agg(
                json_build_object(
                    'type', ua.type,
                    'timestamp', ua.timestamp,
                    'duration_ms', ua.duration_ms,
                    'metadata', ua.metadata
                )
            )
            FROM public.user_activities ua
            WHERE ua.user_id = p_user_id
        ),
        'feedback', (
            SELECT json_agg(row_to_json(uf.*))
            FROM public.user_feedback uf
            WHERE uf.user_id = p_user_id
        ),
        'achievements', (
            SELECT json_agg(row_to_json(uach.*))
            FROM public.user_achievements uach
            WHERE uach.user_id = p_user_id
        ),
        'recipes', (
            SELECT json_build_object(
                'created_recipes', (
                    SELECT json_agg(row_to_json(r.*))
                    FROM public.recipes r
                    WHERE r.created_by = p_user_id
                ),
                'user_recipe_interactions', (
                    SELECT json_agg(row_to_json(ur.*))
                    FROM public.user_recipes ur
                    WHERE ur.user_id = p_user_id
                ),
                'meal_plans', (
                    SELECT json_agg(row_to_json(mp.*))
                    FROM public.meal_plans mp
                    WHERE mp.user_id = p_user_id
                )
            )
        ),
        'pantry', (
            SELECT json_build_object(
                'current_items', (
                    SELECT json_agg(row_to_json(pi.*))
                    FROM public.pantry_items pi
                    WHERE pi.user_id = p_user_id
                ),
                'purchase_history', (
                    SELECT json_agg(row_to_json(ph.*))
                    FROM public.purchase_history ph
                    WHERE ph.user_id = p_user_id
                ),
                'waste_tracking', (
                    SELECT json_agg(row_to_json(wt.*))
                    FROM public.waste_tracking wt
                    WHERE wt.user_id = p_user_id
                )
            )
        ),
        'usage_data', (
            SELECT json_build_object(
                'quotas', (
                    SELECT json_agg(row_to_json(uq.*))
                    FROM public.usage_quotas uq
                    WHERE uq.user_id = p_user_id
                ),
                'ai_usage', (
                    SELECT json_agg(row_to_json(aiul.*))
                    FROM public.ai_usage_logs aiul
                    WHERE aiul.user_id = p_user_id
                ),
                'rate_limits', (
                    SELECT json_agg(row_to_json(rl.*))
                    FROM public.rate_limits rl
                    WHERE rl.user_id = p_user_id
                )
            )
        )
    ) INTO user_data;

    RETURN user_data;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 4. GDPR DATA DELETION (RIGHT TO BE FORGOTTEN)
-- =====================================================

CREATE OR REPLACE FUNCTION delete_user_gdpr_data(
    p_user_id UUID,
    p_deletion_type TEXT DEFAULT 'anonymize' -- 'anonymize' or 'hard_delete'
) RETURNS void AS $$
DECLARE
    v_user_exists BOOLEAN;
BEGIN
    -- Only allow users to delete their own data or admins
    IF auth.uid() != p_user_id AND NOT EXISTS(
        SELECT 1 FROM public.user_profiles
        WHERE id = auth.uid() AND is_admin = true
    ) THEN
        RAISE EXCEPTION 'Unauthorized: Can only delete own data';
    END IF;

    -- Check if user exists
    SELECT EXISTS(SELECT 1 FROM public.user_profiles WHERE id = p_user_id) INTO v_user_exists;
    IF NOT v_user_exists THEN
        RAISE EXCEPTION 'User not found';
    END IF;

    -- Log the deletion request
    INSERT INTO public.audit_logs (user_id, action_type, table_name, additional_info)
    VALUES (p_user_id, 'GDPR_DELETE', 'user_data', json_build_object('deletion_type', p_deletion_type));

    IF p_deletion_type = 'hard_delete' THEN
        -- Hard delete: Remove all user data
        DELETE FROM public.encrypted_user_data WHERE user_id = p_user_id;
        DELETE FROM public.user_preferences WHERE user_id = p_user_id;
        DELETE FROM public.user_subscriptions WHERE user_id = p_user_id;
        DELETE FROM public.payment_history WHERE user_id = p_user_id;
        DELETE FROM public.usage_quotas WHERE user_id = p_user_id;
        DELETE FROM public.ai_usage_logs WHERE user_id = p_user_id;
        DELETE FROM public.rate_limits WHERE user_id = p_user_id;
        DELETE FROM public.scan_history WHERE user_id = p_user_id;
        DELETE FROM public.user_activities WHERE user_id = p_user_id;
        DELETE FROM public.user_feedback WHERE user_id = p_user_id;
        DELETE FROM public.user_achievements WHERE user_id = p_user_id;
        DELETE FROM public.user_recipes WHERE user_id = p_user_id;
        DELETE FROM public.meal_plans WHERE user_id = p_user_id;
        DELETE FROM public.pantry_items WHERE user_id = p_user_id;
        DELETE FROM public.purchase_history WHERE user_id = p_user_id;
        DELETE FROM public.waste_tracking WHERE user_id = p_user_id;
        -- Finally delete the profile (this will cascade to auth.users)
        DELETE FROM public.user_profiles WHERE id = p_user_id;
    ELSE
        -- Anonymize: Replace personal data with anonymous values
        UPDATE public.user_profiles SET
            username = 'deleted_user_' || substring(id::text, 1, 8),
            display_name = 'Deleted User',
            email = 'deleted+' || substring(id::text, 1, 8) || '@example.com',
            avatar_url = NULL,
            bio = NULL,
            phone_number = NULL,
            marketing_consent = false,
            data_processing_consent = false
        WHERE id = p_user_id;

        -- Anonymize scan history (keep for analytics but remove personal info)
        UPDATE public.scan_history SET
            user_feedback = NULL,
            location = NULL
        WHERE user_id = p_user_id;

        -- Anonymize activities (keep type but remove metadata)
        UPDATE public.user_activities SET
            metadata = '{}'::jsonb,
            anonymized_location = NULL
        WHERE user_id = p_user_id;

        -- Anonymize feedback
        UPDATE public.user_feedback SET
            comment = '[Content removed by user request]',
            tags = '{}',
            image_urls = '{}'
        WHERE user_id = p_user_id;

        -- Delete sensitive data
        DELETE FROM public.encrypted_user_data WHERE user_id = p_user_id;
        DELETE FROM public.user_preferences WHERE user_id = p_user_id;
    END IF;

    RAISE NOTICE 'GDPR deletion completed for user % with type %', p_user_id, p_deletion_type;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 5. DATA RETENTION POLICIES
-- =====================================================

-- Create data retention configuration
CREATE TABLE IF NOT EXISTS public.data_retention_policies (
    id SERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    retention_days INTEGER NOT NULL,
    deletion_field TEXT NOT NULL, -- field to check for age
    conditions JSONB DEFAULT '{}'::jsonb, -- additional conditions
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insert default retention policies
INSERT INTO public.data_retention_policies (table_name, retention_days, deletion_field, conditions) VALUES
('audit_logs', 2555, 'created_at', '{}'), -- 7 years for audit logs
('user_activities', 1095, 'created_at', '{}'), -- 3 years for activities
('scan_history', 365, 'scanned_at', '{"anonymous_only": true}'), -- 1 year for anonymous scans
('ai_usage_logs', 730, 'created_at', '{}'), -- 2 years for AI usage
('translation_cache', 180, 'last_used_at', '{"usage_count": "< 5"}') -- 6 months for unused translations
ON CONFLICT DO NOTHING;

-- Function to clean up old data based on retention policies
CREATE OR REPLACE FUNCTION cleanup_old_data()
RETURNS TABLE (
    table_name TEXT,
    deleted_count BIGINT
) AS $$
DECLARE
    policy RECORD;
    delete_count BIGINT;
    delete_sql TEXT;
BEGIN
    FOR policy IN
        SELECT * FROM public.data_retention_policies
        WHERE is_active = true
    LOOP
        -- Build deletion SQL based on policy
        delete_sql := format('DELETE FROM %I WHERE %I < NOW() - INTERVAL ''%s days''',
            policy.table_name,
            policy.deletion_field,
            policy.retention_days
        );

        -- Add additional conditions if specified
        IF policy.conditions != '{}' THEN
            -- This is a simplified version - in production you'd want more sophisticated condition handling
            delete_sql := delete_sql || ' AND created_at IS NOT NULL';
        END IF;

        -- Execute deletion and get count
        EXECUTE delete_sql;
        GET DIAGNOSTICS delete_count = ROW_COUNT;

        -- Log the cleanup
        INSERT INTO public.audit_logs (action_type, table_name, additional_info)
        VALUES ('DATA_CLEANUP', policy.table_name, json_build_object('deleted_count', delete_count, 'retention_days', policy.retention_days));

        -- Return result
        RETURN QUERY SELECT policy.table_name, delete_count;
    END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6. SECURITY FUNCTIONS
-- =====================================================

-- Function to log security events
CREATE OR REPLACE FUNCTION log_security_event(
    p_user_id UUID,
    p_event_type TEXT,
    p_severity TEXT DEFAULT 'INFO', -- INFO, WARNING, ERROR, CRITICAL
    p_details JSONB DEFAULT '{}'::jsonb,
    p_ip_address INET DEFAULT NULL
) RETURNS void AS $$
BEGIN
    INSERT INTO public.audit_logs (
        user_id, action_type, table_name, additional_info, ip_address, success
    ) VALUES (
        p_user_id, 'SECURITY_EVENT', 'security_log',
        json_build_object(
            'event_type', p_event_type,
            'severity', p_severity,
            'details', p_details
        ),
        p_ip_address,
        p_severity NOT IN ('ERROR', 'CRITICAL')
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check for suspicious activity
CREATE OR REPLACE FUNCTION check_suspicious_activity(p_user_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
    v_recent_failed_logins INTEGER;
    v_unusual_locations INTEGER;
    v_rapid_requests INTEGER;
BEGIN
    -- Check for multiple failed login attempts
    SELECT COUNT(*) INTO v_recent_failed_logins
    FROM public.audit_logs
    WHERE user_id = p_user_id
    AND action_type = 'SECURITY_EVENT'
    AND additional_info->>'event_type' = 'FAILED_LOGIN'
    AND created_at > NOW() - INTERVAL '1 hour';

    -- Check for requests from multiple IP addresses
    SELECT COUNT(DISTINCT ip_address) INTO v_unusual_locations
    FROM public.audit_logs
    WHERE user_id = p_user_id
    AND created_at > NOW() - INTERVAL '15 minutes'
    AND ip_address IS NOT NULL;

    -- Check for rapid API requests
    SELECT COUNT(*) INTO v_rapid_requests
    FROM public.audit_logs
    WHERE user_id = p_user_id
    AND created_at > NOW() - INTERVAL '5 minutes';

    -- Flag as suspicious if any threshold exceeded
    IF v_recent_failed_logins > 5 OR v_unusual_locations > 3 OR v_rapid_requests > 100 THEN
        PERFORM log_security_event(p_user_id, 'SUSPICIOUS_ACTIVITY', 'WARNING',
            json_build_object(
                'failed_logins', v_recent_failed_logins,
                'unusual_locations', v_unusual_locations,
                'rapid_requests', v_rapid_requests
            )
        );
        RETURN true;
    END IF;

    RETURN false;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 7. CREATE AUDIT TRIGGERS FOR CRITICAL TABLES
-- =====================================================

-- Generic audit trigger function
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
DECLARE
    v_old_data JSONB;
    v_new_data JSONB;
    v_changed_fields TEXT[];
BEGIN
    -- Build old and new data JSON
    IF TG_OP = 'DELETE' THEN
        v_old_data := row_to_json(OLD)::jsonb;
        v_new_data := NULL;
    ELSIF TG_OP = 'UPDATE' THEN
        v_old_data := row_to_json(OLD)::jsonb;
        v_new_data := row_to_json(NEW)::jsonb;
        -- Find changed fields
        SELECT array_agg(key) INTO v_changed_fields
        FROM jsonb_each(v_old_data)
        WHERE value != COALESCE(v_new_data->key, 'null'::jsonb);
    ELSE -- INSERT
        v_old_data := NULL;
        v_new_data := row_to_json(NEW)::jsonb;
    END IF;

    -- Insert audit log
    INSERT INTO public.audit_logs (
        user_id, action_type, table_name, record_id,
        old_values, new_values, changed_fields
    ) VALUES (
        auth.uid(),
        TG_OP,
        TG_TABLE_NAME,
        COALESCE(NEW.id::text, OLD.id::text),
        v_old_data,
        v_new_data,
        v_changed_fields
    );

    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    ELSE
        RETURN NEW;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Apply audit triggers to critical tables
DROP TRIGGER IF EXISTS audit_user_profiles ON public.user_profiles;
CREATE TRIGGER audit_user_profiles
    AFTER INSERT OR UPDATE OR DELETE ON public.user_profiles
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

DROP TRIGGER IF EXISTS audit_user_subscriptions ON public.user_subscriptions;
CREATE TRIGGER audit_user_subscriptions
    AFTER INSERT OR UPDATE OR DELETE ON public.user_subscriptions
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

DROP TRIGGER IF EXISTS audit_payment_history ON public.payment_history;
CREATE TRIGGER audit_payment_history
    AFTER INSERT OR UPDATE OR DELETE ON public.payment_history
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

-- 8. GRANT PERMISSIONS
-- =====================================================

-- Grant permissions to authenticated users
GRANT SELECT ON public.audit_logs TO authenticated;
GRANT EXECUTE ON FUNCTION export_user_gdpr_data TO authenticated;
GRANT EXECUTE ON FUNCTION delete_user_gdpr_data TO authenticated;
GRANT EXECUTE ON FUNCTION log_security_event TO authenticated;
GRANT EXECUTE ON FUNCTION check_suspicious_activity TO authenticated;

-- Grant admin-only permissions
GRANT ALL ON public.data_retention_policies TO service_role;
GRANT EXECUTE ON FUNCTION cleanup_old_data TO service_role;

-- 9. SCHEDULED CLEANUP
-- =====================================================

-- Note: In production, you would set up a cron job or scheduled function to run this
-- For now, we'll create the function that can be called manually or by external scheduler

COMMENT ON FUNCTION cleanup_old_data() IS 'Run this function daily to clean up old data according to retention policies';

-- Success notification
DO $$
BEGIN
    RAISE NOTICE 'üîí Security and GDPR compliance implemented successfully!';
    RAISE NOTICE 'üìã Audit log system for tracking all database changes';
    RAISE NOTICE 'üîê Data encryption for sensitive user information';
    RAISE NOTICE 'üì§ GDPR data export function for user data portability';
    RAISE NOTICE 'üóëÔ∏è GDPR data deletion with anonymization options';
    RAISE NOTICE '‚è∞ Data retention policies for automatic cleanup';
    RAISE NOTICE 'üõ°Ô∏è Security event logging and suspicious activity detection';
    RAISE NOTICE 'üîç Audit triggers on critical tables';
    RAISE NOTICE '‚ö†Ô∏è Remember to set up scheduled cleanup job for data retention!';
END $$;